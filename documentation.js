import RNCouchbaseLite from './index';

// --- Documentation ------------------------------------------------------------------

const Documentation = {};
Documentation.Basics = async function(databaseName = 'testA') {

	// - Database is optional in all calls. Default database name is 'cbdb'

	// - Save Document
	// Just about any JS object can be saved as a document. A document-id is generated by CouchbaseLite.
	const document = {
		type : 'garbage',
		foo  : ['boop', 'beep'],
		bar  : 14.7,
		baz  : {
			bork : true,
			bark : ['bananas']
		}
	};
	// Save:
	const documentId = await RNCouchbaseLite.saveDocument({ databaseName, document });

	// You can also specify a document-id, if you don't want an auto-generated one.
	await RNCouchbaseLite.saveDocument({ databaseName, document: { id: 'GarbageRecordAlpha1', ...document } });


	// - Get Document
	// A document can be retrieved by its' document-id, but the document-id is not included in the returned document by default.
	// (Deleted documents cannot be retrieved this way. Use 'getDocuments' with the isDeleted META: tag to get deleted documents.)
	const documentFromDB = await RNCouchbaseLite.getDocument({ databaseName, documentId }); // Document is anonymous

	// - Update Document
	documentFromDB.id = documentId; // Include an existing document-id to update an existing record
	documentFromDB.bar *= 1.00014; // (make change(s))
	documentFromDB.baz.bark[0] = 'bandanas';
	await RNCouchbaseLite.saveDocument({ databaseName, document: documentFromDB }); // This will fire change events, even if the saved and old documents are the same.

	// - Create Index
	await RNCouchbaseLite.createIndex({ databaseName, indexFields: ['type'] }); // Does not create duplicate indexes if called multiple times
	await RNCouchbaseLite.createIndex({ databaseName, indexFields: ['bar', 'baz'] });

	// - Delete Index
	await RNCouchbaseLite.deleteIndex({ databaseName, indexName: 'barbazValueIndex' });

	// - Delete Document
	await RNCouchbaseLite.deleteDocument({ databaseName, documentId });

	// - Database Metadata
	const metadata = await RNCouchbaseLite.getDatabaseMetadata({ databaseName });

	// - All Documents
	const documents = await RNCouchbaseLite.getDocuments({ from: databaseName });

	// - Deleted Documents Metadata
	var deletedDocuments = await RNCouchbaseLite.getDocuments({
		select	: ['id', 'META:expiration', 'META:revisionID', 'META:sequence', 'META:isDeleted'],
		from	: databaseName,
		where	: [{ 'META:isDeleted': true }]
	});

	// - Purge Document
	await RNCouchbaseLite.purgeDocument({ databaseName, documentId });

	// - Delete Database
	// await RNCouchbaseLite.deleteDatabase({ databaseName });

	// - Database Exists
	const databaseExists = await RNCouchbaseLite.databaseExists({ databaseName });

};

Documentation.Query = async function(databaseName = 'testA') {

	// Import TestA Objects  - These are test javascript objects to be stored as 'documents' in the couchbaselite database.
	await this.importTestObjects(databaseName);


	// ---- Query Documents -----------------------------------------------------------

	// All Documents
	let documents = await RNCouchbaseLite.getDocuments(); // 'cbdb' is the default database


	// Specify database with the 'from' property.
	// Non-existent databases are automatically created.
	documents = await RNCouchbaseLite.getDocuments({ from: databaseName });
	// By default, all document properties are returned, but not 'id' (document-id)
	// console.log(`All documents from ${databaseName} (no 'id' column): ${JSON.stringify(documents)}`);


	// Use the 'select' property to specify a list of properties to include in the returned documents.
	// The 'id' property (document-id) can also be specified. Properties that do not exist on a document will be ignored.
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['id', 'numProp', 'stringProp'],
		from	: databaseName
	});


	// Use the 'limit' property to return the first n results from the possible resultset
	documents = await RNCouchbaseLite.getDocuments({
		from	: databaseName,
		limit	: 2
	});


	// Use the 'offset' property to skip the first n results from the possible resultset
	// Use the 'offset' property together with the 'limit' property together for pagination
	documents = await RNCouchbaseLite.getDocuments({
		from	: databaseName,
		limit	: 2,
		offset	: 6
	});


	// Filter results with the 'where' property. By default, each key:value pair is a left:right equal-to comparator
	// where 'left' (the key) is a property-name expression and 'right' (the value) is a static value expression (number, string, boolean, etc.).
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['numProp', 'stringProp'],
		from	: databaseName,
		where	: [{ numProp: 2 }]
	});


	// 'where' is a list of objects. Each object is connected by a logical 'OR', while each key:value pair is connected by a logical 'AND'
	// This query retrieves the 'id', 'type' & 'numProp' properties for every document that has a (type of 'example' AND a numProp of 3) OR has a (type of 'garbage')
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['id', 'type', 'numProp'],
		from	: databaseName,
		where	: [{ type: 'example', numProp: 3 }, { type: 'garbage' }]
	});


	// child and grandchild properties are addressed using dot-notation.
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['objectProp'],
		from	: databaseName,
		where	: [{ type: 'example', 'objectProp.objectProp.bar': 42 }]
	});


	// Expressions can include special commands to modify them.
	// Here, we are using the PROP: command to create a property-expression for 'objectProp.boolProp' instead of the default, static value-expression
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['boolProp', 'objectProp.boolProp'],
		from	: databaseName,
		where	: [{ type: 'example', boolProp: 'PROP:objectProp.boolProp' }]
	});


	// The left expression (keys) can use commands, too.
	// Here, we are using the UPPER: command to uppercase the 'stringProp' property and compare it to the string, 'PIZZA'.
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['stringProp'],
		from	: databaseName,
		where	: [{ type: 'example', 'UPPER:stringProp': 'PIZZA' }]
	});


	// Expression commands can also be chained.
	// We have to use the STRING: and PROP: commands to override the defaults.
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['stringProp'],
		from	: databaseName,
		where	: [{ type: 'example', 'STRING:PIZZA': 'UPPER:PROP:stringProp' }]
	});


	// Expression commands are also available in select-expressions.
	// Additional parameters for commands are delimited by forward-slashes.
	// Math commands are partially available - right-side expressions aren't supported, only numbers
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['ROUND/3:DIVIDE/7:decimalProp', 'UPPER:objectProp.stringProp'],
		from	: databaseName,
		where	: [{ type: 'example' }]
	});


	// Aliases are assigned with the '=' delimiter.
	// For more commands, read the source code in the Swift module for this project
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['LENGTH:objectProp.stringProp=stringLength', 'LENGTH[]:arrayProp=arrayLength', 'STRING:This is a static string.=stupidString'],
		from	: databaseName,
		where	: [{ type: 'example' }]
	});

};

Documentation.ComparatorsAndGrouping = async function(databaseName = 'testA') {


	// ---- Comparators ---------------------------------------------------------------

	// The default comparator for key:value expressions is EQUALTO().
	let documents = await RNCouchbaseLite.getDocuments({
		select	: ['id', 'stringProp'],
		from	: databaseName,
		where	: [{ stringProp: 'pickles' }] // Defaults to EQUALTO(pickles)
	});


	// The LIKE() comparator can be used to search inside of strings
	// '%' can be used to represent 0 or more wildcard characters. '_' can be used to represent 1 wildcard character.
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['id', 'objectProp.stringProp'],
		from	: databaseName,
		where	: [{ 'objectProp.stringProp': 'LIKE(%dessert%)' }]
	});


	// Other comparators can be specified on the right-expression (the value side of the key:value pair) using a function-call-like form
	documents = await RNCouchbaseLite.getDocuments({
		from : databaseName,
		where : [
			{ 'objectProp.stringProp': 'CONTAINS(dessert)' }, // CONTAINS() Searches inside strings for a specific substring.
			{ arrayProp: 'CONTAINS[](elbow)' }, // CONTAINS[]() Searches inside arrays for an expression.
			{ decimalProp: 'GT(0.7)' }, // GT() Returns true if the left expression is greater-than the right expression.
			{ 'ADD/1:MULTIPLY/2:numProp': 'GTE(PROP:objectProp.objectProp.bar)' }, // GTE() Returns true if the left expression is greater-than-or-equal-to the right expression.
			{ numProp: 'IN(3,4)' }, // IN() Search in a list of expressions. Left-side defaults to PROPERTY. Right-side defaults to a list of comma-separated INT64s.
			{ 'STRING:tone': 'IN(PROP:stringProp,PROP:objectProp.objectProp.foo)' }, // IN() Example 2: Searching in list of properties.
			{ numProp: 'IS(INT:3)' }, // IS() Is similar to EQUALTO, but the CouchbaseLiteSwift documentation doesn't make clear what the difference is.
			{ numProp: 'ISNOT(INT:3)' }, // ISNOT() Is similar to NOTEQUALTO, but the CouchbaseLiteSwift documentation doesn't make clear what the difference is not.
			{ objectProp: 'ISNULL()' }, // ISNULL() Returns true if the left expression is null or missing.
			{ foo: 'NOTNULL()' }, // NOTNULL() Returns true if the left expression exists and is not null.
			{ 'objectProp.numProp': 'LT(2004)' }, // LT() Returns true if the left expression is less-than the right expression.
			{ decimalProp: 'LTE(0.4)' }, // LTE() Returns true if the left expression is less-than-or-equal-to the right expression.
			{ stringProp: 'LIKE(%an%ich%)' }, // LIKE() Searches inside of strings with wildcards. '%' represents 0 or more characters. '_' represents 1 character.
			{ boolProp: '!(PROP:objectProp.boolProp)' }, // NOTEQUALTO() Returns true if the left expression does not equal the right expression.
			{ 'objectProp.stringProp': 'REGEX([0-9])' }, // REGEX() Searches inside string with Regular-Expressions. // WARNING: Some regex can cause a fatal error in aplication
		]
	});



	// ---- Grouping / Ordering -------------------------------------------------------


	// Use the 'groupBy' property to list expressions to group the query results by.
	// Grouping queries are most often used with aggregate select expressions.
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['numProp', 'ROUND/2:AVG:decimalProp=averageDecimal', 'COUNT:numProp=documentCount', 'SUM:numProp=numSum'],
		from	: databaseName,
		where	: [{ type: 'example' }],
		groupBy	: ['numProp']
	});


	// Use the 'orderBy' property to specify an ordered list of sorting expressions.
	// Append, '>DESC' or '>DESCENDING' to the end of any sorting expression to reverse it
	documents = await RNCouchbaseLite.getDocuments({
		select	: ['numProp', 'ROUND/2:AVG:decimalProp=avgDeci', 'MIN:objectProp.decimalProp=minObDeci', 'MAX:objectProp.decimalProp=maxObDeci'],
		from	: databaseName,
		where	: [{ type: 'example' }],
		groupBy	: ['numProp'],
		orderBy	: ['numProp>DESC']
	});

};

Documentation.Joins = async function(databaseName = 'testA') {


	// ---- Join ----------------------------------------------------------------------


	// Use the 'join' property to specify a list of join operations.
	// Note: In javascript, brackets "[]" around a key in a key:value pair enable a computed property name.
	let documents = await RNCouchbaseLite.getDocuments({
		select	: undefined, // Without specifying any select expressions, the query will only return properties from the 'from' data source.
		from	: `${databaseName}=events`, // An alias MUST be specified for every data source.
		join	: { // For each join, the key defines the database and alias, and the value (ON clause) is an array of objects (functionally identical to WHERE clauses).
			[`${databaseName}=participants`] : [{ // Data sources MUST be specified for property expressions in the format: 'source*property' (or 'UPPER:source*property.childprop.etc', for example)
				'participants*type' : 'person', // Each data source MUST be filtered (as done here, for example) for a meaningful join
				'events*peopleInvolved' : 'CONTAINS[](PROP:participants*personID)' // Here, we are specifying the relation between the two sources (events & participants)
			}] // Each object is connected by a logical 'OR', while each key-value pair is connected by a logical 'AND'
		},
		where	: [{ 'events*type': 'event' }] // Define (filter) the 'from' data source here
	});


	// Use select-expressions to return data from all sources.
	documents = await RNCouchbaseLite.getDocuments({
		select : [
			'events*eventID', // Data sources MUST be specified for property expressions in the format: 'source*property'
			'reportDateTime', // However, if omitted, the source will default to the 'from' data source ('events' in this example).
			'fullName', // Invalid property names will be ignored ('events*fullName' would be invalid).
			'participants*fullName=participant' // Aliases are assigned with the '=' delimiter.
		],
		from : `${databaseName}=events`,
		join : { [`${databaseName}=participants`]: [{ 'participants*type': 'People', 'events*peopleInvolved': 'CONTAINS[](PROP:participants*personID)' }] },
		where : [{ 'events:type': 'event' }]
	});



	// Multiple joins follow the same pattern
	documents = await RNCouchbaseLite.getDocuments({
		select : [ 'eventID', 'reportDateTime', 'reporter*fullName=Reporter', 'participants*fullName=Participant'],
		from : `${databaseName}=events`,
		join : {
			[`${databaseName}=reporter`] : [{ 'reporter*type': 'People', 'events*peopleInvolved': 'PROP:reporter*personID' }],
			[`${databaseName}=participants`] : [{ 'participants*type': 'People', 'events*peopleInvolved': 'CONTAINS[](PROP:participants*personID)' }]
		},
		where : [{ 'events*type': 'event', 'participants*lastName': 'Thompson' }]
	});

};

Documentation.Conclusion = async function(databaseName = 'testA') {


	// ---- Conclusion ----------------------------------------------------------------


	// Queries can be very simple
	let documents = await RNCouchbaseLite.getDocuments({ where: [{ type: 'event', people_event: true }] });


	// Or complicated
	documents = await RNCouchbaseLite.getDocuments({
		select	: [ 'reportDateTime', 'entityId', 'COUNT:eventID=dailyEventTotal', 'SUM:INT:participants*isCelebrity=celebritiesInvolved'],
		from	: `${databaseName}=events`,
		join	: {
			[`${databaseName}=reporter`] : [{ 'reporter*type': 'People', 'events*peopleInvolved': 'PROP:reporter*personID' }],
			[`${databaseName}=participants`] : [{ 'participants*type': 'People', 'events*peopleInvolved': 'CONTAINS[](PROP:participants*personID)' }]
		},
		where	: [
			{ 'events:type': 'event', 'participants*lastName': 'Jetson' },
			{ 'events:type': 'event', 'participants*isCelebrity': true }
		],
		groupBy	: ['reportDateTime', 'entityId'],
		orderBy : ['entityId', 'reportDateTime>DESCENDING'],
		limit	: 5,
		offset	: 0
	});


	// But might also look something like this ...
	const modelIDs = [1622757408209, 1623167531143]; // (Example numbers)
	const modelInfo = { // (Example Model Config)
		type: 'event',
		idAttribute: 'eventID',
		columns: ['type', 'eventID', 'peopleInvolved', 'reportDateTime', 'reporter']
	};

	// ... get
	documents = await RNCouchbaseLite.getDocuments({
		select	: [ 'id=documentId', ...modelInfo.columns ],
		from	: databaseName,
		where	: [{ type: modelInfo.type, [modelInfo.idAttribute]: `IN(${modelIDs.join(',')})` }]
	});

};

Documentation.Events = async function(databaseName = 'testA') {


	// ---- Events --------------------------------------------------------------------

	// Subscribe to Events manually:
	RNCouchbaseLite.Events.addListener('Database.Change', (eventData) => { // (eventName, eventFunction)
		console.log(`Database.Change, eventData: ${JSON.stringify(eventData)}`);
	});
	const docId = await RNCouchbaseLite.saveDocument({ databaseName, document: { type: 'garbage', foo: 7, bar: 'trove' } }); // Demonstrate

	// Set Event Handler Example For All Events: (This should only need to be called once per app start)
	RNCouchbaseLite.Events.setEventHandler((eventName, eventData) => {
		console.log(`eventName: ${eventName},  eventData: ${JSON.stringify(eventData)}`);
	});
	await RNCouchbaseLite.saveDocument({ databaseName, document: { id: docId, type: 'garbage', foo: 7.14, bar: 'lode' } }); // Demonstrate

	// Remove All Listeners:
	RNCouchbaseLite.Events.removeAllListeners();

	// Remove All Listeners for just one Event:
	RNCouchbaseLite.Events.removeAllListeners('Database.Change');

	// Events & Details:
	// Document.Change - Update Existing Document (Local), Publishes BEFORE Database.Change Event
	// Database.Change - New Document (Local), Update Existing Document (Local), Publishes BEFORE Replication Events (push AND pull), Doesn't fire for documents that are filtered by the pull filter
	// Replication.Error - A Replication Error has occured. Error included.
	// Replication.Stopped - Replication has stopped
	// Replication.Change - Replication Status changes: offline, connecting, busy, idle, stopped
	// Replication.Push - Push Replication, includes list of documents, does not fire for documents filtered by the push filter
	// Replication.Pull - Pull Replication, includes list of documents (list includes documents/updates that were rejected by the pull filter)
	// Replication.Pull.Delete - File has been Remotely Deleted. Event only fires if you pass, 'enablePullDeleteEvent:true; to 'startReplicator'
	// Replication.Pull.AccessRemoved - File Access has been Remotely Removed. Event only fires if you pass, 'enableAccessRemovedEvent:true; to 'startReplicator'

};

Documentation.Replication = async function(databaseName = 'testA') {


	// ---- Replication ---------------------------------------------------------------

	// startReplicator
	let replicatorName = await RNCouchbaseLite.startReplicator({
		databaseName	: undefined, // (Optional) Defaults to 'cbdb'
		target			: '', // Example: "wss://10.1.1.12:8092/actDb"
		replicatorType	: 'pushAndPull', // push, pull, pushAndPull (default)
		continuous		: true, // false = adhoc. Adhoc replication stops when finished
		channels		: ['example'], // A list of channels to sync. By default, all channels are replicated. Channels are determined by the sync function in the SyncGateway config file.
		documentIDs		: ['df8b365727bd467e355881f7530794fd', 'GarbageRecordAlpha1'], // A list of documents (by id) to sync. By default, all documents are replicated.
		name			: 'testReplicator1', // A unique handle for the replicator oject. By default, a name is generated.
		heartbeat		: 30, // Websockets keep-alive heartbeat interval in seconds. Default is 300 seconds (5 minutes)
		selfSigned		: false, // Allows connections with servers with self-signed certificates. DO NOT USE THIS! See https://letsencrypt.org/
		certificateURL	: 'https://xxxxxxx', // The URL of the pinned certificate to use with the replicator connection.
		certificate		: 'Rm9yIEV4YW1wbGU=', // Base64 encoded string containing the pinned certificate to use with the replicator connection.
		authenticationType	: '', // 'BASIC' or 'SESSION'. Defaults to 'SESSION'
		username		: 'testuser1', // Required if authenticationType is set to 'BASIC'
		password		: 'coolest password ever', // Required if authenticationType is set to 'BASIC'
		sessionID		: '', // Required if authenticationType is 'SESSION'. This is the session token.
		headers			: { 'x_client_secret': 'fks04iufbe8hd' }, // A list of additional HTTPS (WSS) headers to use with every request.
		allowReplicatingInBackground	: false, // Replicate even when app is in the background. (If setting the value to [true], please [get user/device permission] properly.) Note: iOS doesn't seem to allow this for more than a moment.
		enableAccessRemovedEvent : false, // Fire the 'Replication.Pull.AccessRemoved' event when the user remotely loses access to a document.
		enablePullDeleteEvent : false, // Fire the 'Replication.Pull.Delete' event when a file is remotely deleted. (Documents won't delete locally if they are caught in the pull filter)
		verboseEvents	: false, // Include more data about sync updates in some events. This could potentially cause performance issues if large amounts of data are generated at once.
		resetCheckpoint	: false, // When the local checkpoint is reset, the replicator will sync all changes since the beginning of time from the remote database.
		// Documents matching the push or pull filters will be excluded from push or pull replication respecively. String, Number, and Boolean values can be used.
		pushFilter		: { match: { status: 'complete' } }, // If the 'match' filter is defined, a document must match at least one of the defined filter properties.
		pullFilter		: { not: { type: ['junk', 'testA', 'person', 'event'] } }, // If the 'not' filter is defined, a document must not match any of the defined filter properties.
	});


	// stopReplicator
	await RNCouchbaseLite.stopReplicator({ replicatorName });

};





// --- Support For Documentation ------------------------------------------------------

Documentation.importTestObjects = async () => {

	const testObjects = [
		{ type: 'example', boolProp: true, numProp: 1, decimalProp: 0.1, stringProp: 'cheeseburgers', arrayProp: ['jalepeno', 'frodo', 'foot', 'guise'], objectProp: { boolProp: true, numProp: 2002, decimalProp: 2.0001, stringProp: 'synthetic proto-amino acid soup plus vitamins and minerals', arrayProp: ['gargoyl', 'jacobson', 'porcupine', 'gossip'], objectProp: { foo: 'sand', bar: 3, foo2: { quake: 'sunflowers' } } } },
		{ type: 'example', boolProp: true, numProp: 1, decimalProp: 0.2, stringProp: 'pizza', arrayProp: ['green bell pepper', 'bilbo', 'hand', 'ruse'], objectProp: { boolProp: false, numProp: 2002, decimalProp: 2.0002, stringProp: 'happy fun-time american school', arrayProp: ['leprechan', 'jerryson', 'girrafe', 'talk'], objectProp: { foo: 'dirt', bar: 4, foo2: { quill: 'serenade' } } } },
		{ type: 'example', boolProp: true, numProp: 2, decimalProp: 0.3, stringProp: 'popsicles', arrayProp: ['red bell pepper', 'merri', 'knee', 'deception'], objectProp: { boolProp: true, numProp: 2003, decimalProp: 2.0003, stringProp: 'hot twist of the knife', arrayProp: ['boogy monster', 'sanderson', 'elephant', 'speech'], objectProp: { foo: 'earth', bar: 5, foo2: { quiver: 'sonata' } } } },
		{ type: 'example', boolProp: true, numProp: 2, decimalProp: 0.4, stringProp: 'pastries', arrayProp: ['yellow bell pepper', 'pippen', 'arm', 'excuse'], objectProp: { boolProp: false, numProp: 2003, decimalProp: 2.0004, stringProp: 'banana band-aids and bandanas', arrayProp: ['the jackson family', 'johnson', 'lion', 'monolouge'], objectProp: { foo: 'gravel', bar: 6, foo2: { quaint: 'support' } } } },
		{ type: 'example', boolProp: true, numProp: 3, decimalProp: 0.5, stringProp: 'burritos', arrayProp: ['habanero', 'samwise', 'leg', 'pretense'], objectProp: { boolProp: true, numProp: 2004, decimalProp: 2.0005, stringProp: 'strong-leg farquart', arrayProp: ['frontier doctor', 'markinson', 'tiger', 'dialog'], objectProp: { foo: 'granite', bar: 7, foo2: { quote: 'single' } } } },
		{ type: 'example', boolProp: false, numProp: 3, decimalProp: 0.6, stringProp: 'manwich', arrayProp: ['ceranos', 'gandolf', 'elbow', 'tactic'], objectProp: { boolProp: false, numProp: 2004, decimalProp: 2.0006, stringProp: 'rock-em sock-em french fries', arrayProp: ['geriatric', 'parkison', 'bear', 'address'], objectProp: { foo: 'gypsum', bar: 8, foo2: { quirk: 'succulant' } } } },
		{ type: 'example', boolProp: false, numProp: 4, decimalProp: 0.7, stringProp: 'bachelor\'s chow', arrayProp: ['grilled jalepeno', 'sauron', 'shoulder', 'strategy'], objectProp: { boolProp: true, numProp: 2005, decimalProp: 2.0007, stringProp: 'surrogate father bbq sauce 45', arrayProp: ['giant', 'clayson', 'otter', 'lecture'], objectProp: { foo: 'guano', bar: 9, foo2: { quark: 'symmetry' } } } },
		{ type: 'example', boolProp: false, numProp: 4, decimalProp: 0.8, stringProp: 'sandwich', arrayProp: ['bannana peppers', 'gollum', 'heel', 'play'], objectProp: { boolProp: false, numProp: 2005, decimalProp: 2.0008, stringProp: 'running through the jungle with the prince of decay', arrayProp: ['gornax', 'dickinson', 'raccoon', 'discussion'], objectProp: { foo: 'stone', bar: 10, foo2: { quandry: 'satisfaction' } } } },
		{ type: 'example', boolProp: false, numProp: 5, decimalProp: 0.9, stringProp: 'pickles', arrayProp: ['sweet peppers', 'boromir', 'knuckle', 'move'], objectProp: { boolProp: true, numProp: 2006, decimalProp: 2.0009, stringProp: 'spinkles dessert topping applicator', arrayProp: ['sprite', 'edmunson', 'sloth', 'rap'], objectProp: { foo: 'rock', bar: 11, foo2: { quell: 'sample' } } } },
		{ type: 'example', boolProp: false, numProp: 5, decimalProp: 1.0, stringProp: 'soylent green', arrayProp: ['gasoline', 'ultron', 'laser aperature', 'flatulation'], objectProp: { boolProp: false, numProp: 2006, decimalProp: 2.0010, stringProp: 'passionate patty and the pursuit of pulsating pectorals', arrayProp: ['cooperating witness', 'perry mason', 'lawyer', 'torture'], objectProp: { foo: 'soul stone', bar: 42, foo2: { quantico: 'superego' } } } },
		{ type: 'person', personID: 1, isCelebrity: false, fullName: 'John Doe', lastName: 'Doe' },
		{ type: 'person', personID: 2, isCelebrity: true, fullName: 'Fred Flintstone', lastName: 'Flintstone' },
		{ type: 'person', personID: 3, isCelebrity: false, fullName: 'George Jetson', lastName: 'Jetson' },
		{ type: 'person', personID: 4, isCelebrity: false, fullName: 'Emmanuel Goldstein', lastName: 'Goldstein' },
		{ type: 'person', personID: 5, isCelebrity: true, fullName: 'Ichabod Crane', lastName: 'Crane' },
		{ type: 'event', eventID: 1, peopleInvolved: [1], reportDateTime: '2020-01-15 13:55:00', reporter: 2 },
		{ type: 'event', eventID: 2, peopleInvolved: [2, 3], reportDateTime: '2020-01-17 16:35:10', reporter: 2 },
		{ type: 'event', eventID: 3, peopleInvolved: [5], reportDateTime: '2020-03-19 11:00:34', reporter: 3 },
		{ type: 'event', eventID: 4, peopleInvolved: [1, 5], reportDateTime: '2020-04-03 06:26:00', reporter: 4 },
		{ type: 'event', eventID: 5, peopleInvolved: [2, 3, 4, 5], reportDateTime: '2020-04-17 18:15:13', reporter: 1 }
	];
	await RNCouchbaseLite.saveDocuments({
		databaseName	: 'testA',
		documents		: testObjects,
	});
};

export default Documentation;
